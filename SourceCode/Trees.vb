Imports System.IO
Imports System.Web.Script.Serialization
Imports System.Windows.Forms
Imports InputModelling.Models.Nodes
Imports InputModelling.Models.Trees.BeliefTree

Namespace Models
    Namespace Trees
        'Tree Extensions
        ''' <summary>
        ''' A Tree is actually a List of Lists
        ''' Root with branches and leaves:
        ''' In this tree the children are the branches: Locations to hold data have been provided.
        ''' These ae not part of the Tree Structure:
        ''' When initializing the structure Its also prudent to Initialize the ChildList;
        ''' Reducing errors; Due to late initialization of the ChildList
        ''' Subsequentially : Lists used in this class are not initialized in this structure.
        ''' Strings inserted with the insert Cmd will be treated as a Trie Tree insert!
        ''' if this tree requires data to be stroed it needs to be stored inside the dataStorae locations
        ''' </summary>
        <ComClass(TryTree.ClassId, TryTree.InterfaceId, TryTree.EventsId)>
        <Serializable>
        Public Class TryTree

#Region "Public Fields"

            Public Const ClassId As String = "28CCB490-7703-401C-BAB3-38FF97BC1AC9"
            Public Const EventsId As String = "CCB5B207-F55E-401A-ABBD-3CF80C6BB6F1"
            Public Const InterfaceId As String = "8B3325F8-5D13-4059-CB9B-B531C10C44B5"

#End Region

#Region "Public Enums"

            ''' <summary>
            ''' Theses are essentially the branches of the Tree....
            ''' if there are no children then the node is a leaf.
            ''' Denoted by the StopCharacter NodeID. or "StopChar" NodeData.
            ''' </summary>
            Public Children As List(Of TryTree)

            ''' <summary>
            ''' Available Variable Storage (boolean)
            ''' </summary>
            Public NodeBool As Boolean

            ''' <summary>
            ''' Available Variable Storage (list of Boolean)
            ''' </summary>
            Public NodeBoolList As List(Of Boolean)

            ''' <summary>
            ''' Used To hold CharacterStr (tries) Also Useful for Creating ID for node;
            ''' : (a String) can be used to store a specific Pathway :
            ''' </summary>
            Public NodeData As String

            ''' <summary>
            ''' Each NodeID: is specific to Its level this id is generated by the tree:
            ''' </summary>
            Public NodeID As CharID

            ''' <summary>
            ''' Available Variable Storage(int)
            ''' </summary>
            Public NodeInt As Integer

            ''' <summary>
            ''' Available Variable Storage (list of Int)
            ''' </summary>
            Public NodeIntList As List(Of Integer)

            ''' <summary>
            ''' the level denotes also how many vertices before returning to the root.
            ''' In a Trie Tree the first node is blank and not included therefore the Vertices are level-1
            ''' </summary>
            Public NodeLevel As Integer

            ''' <summary>
            ''' Available Variable Storage(string)
            ''' </summary>
            Public NodeStr As String

            ''' <summary>
            ''' Available Variable Storage(list of Strings)
            ''' </summary>
            Public NodeStrList As List(Of String)

            Public Sub New(ByRef IntializeChildren As Boolean)
                If IntializeChildren = True Then
                    Children = New List(Of TryTree)
                Else
                End If
            End Sub

            Public Sub New()

            End Sub

            ''' <summary>
            ''' Each Set of Nodes has only 26 ID's ID 0 = stop
            ''' </summary>
            Public Enum CharID

                StartChar = 0
                a = 1
                b = 2
                c = 3
                d = 4
                e = 5
                f = 6
                g = 7
                h = 8
                i = 9
                j = 10
                k = 11
                l = 12
                m = 13
                n = 14
                o = 15
                p = 16
                q = 17
                r = 18
                s = 19
                t = 20
                u = 21
                v = 22
                w = 23
                x = 24
                y = 25
                z = 26
                StopChar = 27
            End Enum

#End Region

#Region "Public Methods"

            ''' <summary>
            ''' Adds string to given trie
            ''' </summary>
            ''' <param name="Tree"></param>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Function AddStringbyChars(ByRef Tree As TryTree, Str As String) As TryTree
                Dim curr As TryTree = Tree
                Dim Pos As Integer = 0
                For Each chr As Char In Str
                    Pos += 1
                    curr = AddStringToTrie(curr, chr, Pos)
                Next
                curr = AddStringToTrie(curr, "StopChar", Pos + 1)
                Return Tree
            End Function

            ''' <summary>
            ''' Adds string to given trie
            ''' </summary>
            ''' <param name="Tree"></param>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Function AddStringbyWord(ByRef Tree As TryTree, Str As String) As TryTree
                Dim curr As TryTree = Tree
                Dim Pos As Integer = 0
                For Each chr As String In Str.Split(" ")
                    Pos += 1

                    curr = AddStringToTrie(curr, chr, Pos)
                Next
                curr = AddStringToTrie(curr, "StopChar", Pos + 1)
                Return Tree
            End Function

            ''' <summary>
            ''' checks if node exists in child nodes (used for trie trees (String added is the key and the data)
            ''' </summary>
            ''' <param name="Nodedata">Char string used as identifier</param>
            ''' <returns></returns>
            Public Shared Function CheckNodeExists(ByRef Children As List(Of TryTree), ByRef Nodedata As String) As Boolean
                'Check node does not exist
                Dim found As Boolean = False
                For Each mNode As TryTree In Children
                    If mNode.NodeData = Nodedata Then
                        found = True
                    Else
                    End If
                Next
                Return found
            End Function

            ''' <summary>
            ''' Returns true if string is contined in trie (prefix) not as Word
            ''' </summary>
            ''' <param name="tree"></param>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Shared Function CheckPrefix(ByRef tree As TryTree, ByRef Str As String) As Boolean
                Str = Str.ToUpper
                Dim CurrentNode As TryTree = tree
                Dim found As Boolean = False

                Dim Pos As Integer = 0
                For Each chrStr As Char In Str
                    Pos += 1

                    'Check Chars
                    If TryTree.CheckNodeExists(CurrentNode.Children, chrStr) = True Then
                        CurrentNode = TryTree.GetNode(CurrentNode.Children, chrStr)
                        found = True
                    Else
                        found = False
                    End If
                Next
                Return found
            End Function

            ''' <summary>
            ''' Returns true if Word is found in trie
            ''' </summary>
            ''' <param name="tree"></param>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Shared Function CheckSentence(ByRef tree As TryTree, ByRef Str As String) As Boolean
                Str = Str.ToUpper
                Dim CurrentNode As TryTree = tree
                Dim found As Boolean = False
                'Position in Characterstr
                Dim Pos As Integer = 0
                For Each chrStr As String In Str.Split(" ")
                    Pos += 1

                    'Check Chars
                    If TryTree.CheckNodeExists(CurrentNode.Children, chrStr) = True Then
                        CurrentNode = TryTree.GetNode(CurrentNode.Children, chrStr)
                        found = True
                    Else
                        'Terminated before end of Word
                        found = False
                    End If
                Next

                'Check for end of word marker
                Return If(found = True, TryTree.CheckNodeExists(CurrentNode.Children, "StopChar") = True, False)

            End Function

            ''' <summary>
            ''' Returns true if string is contined in trie (prefix) not as Word
            ''' </summary>
            ''' <param name="tree"></param>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Shared Function CheckSentPrefix(ByRef tree As TryTree, ByRef Str As String) As Boolean
                Dim CurrentNode As TryTree = tree
                Dim found As Boolean = False
                Str = Str.ToUpper
                Dim Pos As Integer = 0
                For Each chrStr As String In Str.Split(" ")
                    Pos += 1

                    'Check Chars
                    If TryTree.CheckNodeExists(CurrentNode.Children, chrStr) = True Then
                        CurrentNode = TryTree.GetNode(CurrentNode.Children, chrStr)
                        found = True
                    Else
                        found = False
                    End If
                Next
                Return found
            End Function

            ''' <summary>
            ''' Returns true if Word is found in trie
            ''' </summary>
            ''' <param name="tree"></param>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Shared Function CheckWord(ByRef tree As TryTree, ByRef Str As String) As Boolean
                Str = Str.ToUpper
                Dim CurrentNode As TryTree = tree
                Dim found As Boolean = False
                'Position in Characterstr
                Dim Pos As Integer = 0
                For Each chrStr As Char In Str
                    Pos += 1

                    'Check Chars
                    If TryTree.CheckNodeExists(CurrentNode.Children, chrStr) = True Then
                        CurrentNode = TryTree.GetNode(CurrentNode.Children, chrStr)
                        found = True
                    Else
                        'Terminated before end of Word
                        found = False
                    End If
                Next

                'Check for end of word marker
                Return If(found = True, TryTree.CheckNodeExists(CurrentNode.Children, "StopChar") = True, False)

            End Function

            ''' <summary>
            ''' Returns Matched Node to sender (used to recures children)
            ''' </summary>
            ''' <param name="Tree"></param>
            ''' <param name="NodeData"></param>
            ''' <returns></returns>
            Public Shared Function GetNode(ByRef Tree As List(Of TryTree), ByRef NodeData As String) As TryTree
                Dim Foundnode As New TryTree
                For Each item In Tree
                    If item.NodeData = NodeData Then
                        Foundnode = item
                    Else
                    End If
                Next
                Return Foundnode
            End Function

            ''' <summary>
            ''' Insert String into trie
            ''' </summary>
            ''' <param name="tree"></param>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Function InsertByCharacters(ByRef tree As TryTree, ByRef Str As String) As TryTree
                Return AddStringbyChars(tree, Str)
            End Function

            ''' <summary>
            ''' Insert String into trie
            ''' </summary>
            ''' <param name="tree"></param>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Function InsertByWord(ByRef tree As TryTree, ByRef Str As String) As TryTree
                Return AddStringbyWord(tree, Str)
            End Function

            ''' <summary>
            ''' Returns Number of Nodes
            ''' </summary>
            ''' <returns></returns>
            Public Shared Function NumberOfNodes(ByRef Tree As TryTree) As Integer
                Dim Count As Integer = 0
                For Each child In Tree.Children
                    Count += child.NumberOfNodes
                Next
                Return Count
            End Function

            ''' <summary>
            ''' Add characters Iteratively
            ''' CAT
            ''' AT
            ''' T
            ''' </summary>
            ''' <param name="Word"></param>
            ''' <param name="TrieTree"></param>
            Public Function AddItterativelyByCharacter(ByRef TrieTree As TryTree, ByRef Word As String) As TryTree
                'AddWord
                For i = 1 To Word.Length
                    TrieTree.InsertByCharacters(Word)
                    Word = Word.Remove(0, 1)
                Next
                Return TrieTree
            End Function

            ''' <summary>
            ''' AddIteratively characters
            ''' CAT
            ''' AT
            ''' T
            ''' </summary>
            ''' <param name="Word"></param>
            Public Function AddItterativelyByCharacter(ByRef Word As String) As TryTree
                Return AddItterativelyByCharacter(Me, Word)
            End Function

            ''' <summary>
            ''' Add characters Iteratively
            ''' CAT
            ''' AT
            ''' T
            ''' </summary>
            ''' <param name="Word"></param>
            ''' <param name="TrieTree"></param>
            Public Function AddItterativelyByWord(ByRef TrieTree As TryTree, ByRef Word As String) As TryTree
                'AddWord
                Dim x = Word.Split(" ")
                For Each item As String In x
                    TrieTree.InsertByWord(Word)
                    If Word.Length > item.Length + 1 = True Then
                        Word = Word.Remove(0, item.Length + 1)
                    Else
                        Word = ""
                    End If
                Next
                Return TrieTree
            End Function

            ''' <summary>
            ''' AddIteratively characters
            ''' CAT
            ''' AT
            ''' T
            ''' </summary>
            ''' <param name="Word"></param>
            Public Function AddItterativelyByWord(ByRef Word As String) As TryTree
                Return AddItterativelyByWord(Me, Word)
            End Function

            ''' <summary>
            ''' Returns number of Nodes in tree
            ''' </summary>
            ''' <returns></returns>
            Public Function CountNodes(ByRef CurrentCount As Integer) As Integer
                Dim count As Integer = CurrentCount
                For Each child In Me.Children
                    count += 1
                    count = child.CountNodes(count)
                Next
                Return count
            End Function

            Public Function CountWords(ByRef CurrentCount As Integer) As Integer
                Dim count As Integer = CurrentCount
                For Each child In Me.Children
                    If child.NodeID = CharID.StopChar = True Then
                        count += 1

                    End If
                    count = child.CountWords(count)
                Next

                Return count
            End Function

            ''' <summary>
            ''' Creates a Tree With an Empty Root node Called Root! Intializing the StartChar
            ''' </summary>
            ''' <returns></returns>
            Public Function Create() As TryTree
                Return TryTree.MakeTrieTree()
            End Function

            ''' <summary>
            ''' Returns true if String is found as a prefix in trie
            ''' </summary>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Function FindPrefix(ByRef Str As String) As Boolean
                Return TryTree.CheckPrefix(Me, Str)
            End Function

            ''' <summary>
            ''' Returns true if string is found as word in trie
            ''' </summary>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Function FindSentence(ByRef Str As String) As Boolean
                Return TryTree.CheckSentence(Me, Str)
            End Function

            ''' <summary>
            ''' Returns true if String is found as a prefix in trie
            ''' </summary>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Function FindSentPrefix(ByRef Str As String) As Boolean
                Return TryTree.CheckSentPrefix(Me, Str)
            End Function

            ''' <summary>
            ''' Returns true if string is found as word in trie
            ''' </summary>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Function FindWord(ByRef Str As String) As Boolean
                Return TryTree.CheckWord(Me, Str)
            End Function

            ''' <summary>
            ''' deserialize object from Json
            ''' </summary>
            ''' <param name="Str">json</param>
            ''' <returns></returns>
            Public Function FromJson(ByRef Str As String) As TryTree
                Try
                    Dim Converter As New JavaScriptSerializer
                    Dim diag As TryTree = Converter.Deserialize(Of TryTree)(Str)
                    Return diag
                Catch ex As Exception
                    Dim Buttons As MessageBoxButtons = MessageBoxButtons.OK
                    MessageBox.Show(ex.Message, "ERROR", Buttons)
                End Try
                Return Nothing
            End Function

            ''' <summary>
            ''' Checks if current node Has children
            ''' </summary>
            ''' <returns></returns>
            Public Function HasChildren() As Boolean
                Return If(Me.Children.Count > 0 = True, True, False)
            End Function

            ''' <summary>
            ''' Inserts a string into the trie
            ''' </summary>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Function InsertByCharacters(ByRef Str As String) As TryTree
                Return AddStringbyChars(Me, Str)
            End Function

            ''' <summary>
            ''' Inserts a string into the trie
            ''' </summary>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Function InsertByWord(ByRef Str As String) As TryTree
                Return AddStringbyWord(Me, Str)
            End Function

            ''' <summary>
            ''' Returns deepest level
            ''' </summary>
            ''' <returns></returns>
            Public Function LowestLevel() As Integer
                'Gets the level for node
                Dim Level As Integer = Me.NodeLevel

                'Recurses children
                For Each child In Me.Children
                    If Level < child.LowestLevel = True Then
                        Level = child.LowestLevel
                    End If
                Next
                'The loop should finish at the lowest level
                Return Level
            End Function

            'Functions
            ''' <summary>
            ''' Returns Number of Nodes
            ''' </summary>
            ''' <returns></returns>
            Public Function NumberOfNodes() As Integer
                Dim Count As Integer = 0
                For Each child In Me.Children
                    Count += child.NumberOfNodes
                Next
                Return Count
            End Function

            Public Function ToJson() As String
                Dim Converter As New JavaScriptSerializer
                Return Converter.Serialize(Me)

            End Function

#End Region

#Region "Add"

            ''' <summary>
            ''' Displays Contents of trie
            ''' </summary>
            ''' <returns></returns>
            Public Overrides Function ToString() As String

                'TreeInfo
                Dim Str As String = "NodeID " & Me.NodeID.ToString & vbNewLine &
            "Data: " & Me.NodeData & vbNewLine &
            "Node Level: " & NodeLevel.ToString & vbNewLine

                'Data held
                Dim mData As String = ": Data :" & vbNewLine &
               "Int: " & NodeInt & vbNewLine &
               "Str: " & NodeStr & vbNewLine &
               "Boolean: " & NodeBool & vbNewLine

                'Lists
                mData &= "StrLst: " & vbNewLine
                For Each child In Me.NodeStrList
                    mData &= "Str: " & child.ToString() & vbNewLine
                Next
                mData &= "IntLst: " & vbNewLine
                For Each child In Me.NodeIntList
                    mData &= "Str: " & child.ToString() & vbNewLine
                Next
                mData &= "BooleanList: " & vbNewLine
                For Each child In Me.NodeBoolList
                    mData &= "Bool: " & child.ToString() & vbNewLine
                Next

                'Recurse Children
                For Each child In Me.Children
                    Str &= "Child: " & child.ToString()
                Next

                Return Str
            End Function

            ''' <summary>
            ''' Returns a TreeViewControl with the Contents of the Trie:
            ''' </summary>
            Public Function ToView(ByRef Node As TryTree) As System.Windows.Forms.TreeNode
                Dim Nde As New System.Windows.Forms.TreeNode
                Nde.Text = Node.NodeData.ToString.ToUpper &
                "(" & Node.NodeLevel & ")" & vbNewLine

                For Each child In Me.Children
                    Nde.Nodes.Add(child.ToView)

                Next
                Return Nde
            End Function

            ''' <summary>
            ''' Returns a TreeViewControl with the Contents of the Trie:
            ''' </summary>
            ''' <returns></returns>
            Public Function ToView() As System.Windows.Forms.TreeNode
                Dim nde As New System.Windows.Forms.TreeNode
                nde.Text = Me.NodeData.ToString.ToUpper & vbNewLine &
                "(" & Me.NodeLevel & ")" & vbNewLine

                For Each child In Me.Children
                    nde.Nodes.Add(child.ToView)

                Next

                Return nde

            End Function


#End Region

#Region "DATA"

            ''' <summary>
            ''' If node does not exist in child node set it is added
            ''' if node already exists then no node is added a node ID is generated
            ''' </summary>
            ''' <param name="NodeData">Character to be added</param>
            Private Function CreateNode(ByRef NodeData As String, ByRef Level As Integer) As TryTree
                'Create node - 2
                Dim NewNode As New TryTree(True)
                NewNode.NodeData = NodeData
                'create id
                NewNode.NodeID = totalNodeCount
                NewNode.NodeLevel = Level
                Return NewNode
            End Function

            ''' <summary>
            ''' Generates an ID from NodeData
            ''' </summary>
            ''' <param name="Nodedata">Character string for node</param>
            ''' <returns></returns>
            Private Shared Function GenerateNodeID(ByRef Nodedata As String) As CharID
                Dim newnode As New TryTree
                'SET ID for node
                Select Case Nodedata.ToUpper
                    Case "STOPCHAR"
                        newnode.NodeID = CharID.StopChar
                    Case "A"
                        newnode.NodeID = CharID.a
                    Case "B"
                        newnode.NodeID = CharID.b
                    Case "C"
                        newnode.NodeID = CharID.c
                    Case "D"
                        newnode.NodeID = CharID.d
                    Case "E"
                        newnode.NodeID = CharID.e
                    Case "F"
                        newnode.NodeID = CharID.f
                    Case "G"
                        newnode.NodeID = CharID.g
                    Case "H"
                        newnode.NodeID = CharID.h
                    Case "I"
                        newnode.NodeID = CharID.i
                    Case "J"
                        newnode.NodeID = CharID.j
                    Case "K"
                        newnode.NodeID = CharID.k
                    Case "L"
                        newnode.NodeID = CharID.l
                    Case "M"
                        newnode.NodeID = CharID.m
                    Case "N"
                        newnode.NodeID = CharID.n
                    Case "O"
                        newnode.NodeID = CharID.o
                    Case "P"
                        newnode.NodeID = CharID.p
                    Case "Q"
                        newnode.NodeID = CharID.q
                    Case "R"
                        newnode.NodeID = CharID.r
                    Case "S"
                        newnode.NodeID = CharID.s
                    Case "T"
                        newnode.NodeID = CharID.t
                    Case "U"
                        newnode.NodeID = CharID.u
                    Case "V"
                        newnode.NodeID = CharID.v
                    Case "W"
                        newnode.NodeID = CharID.w
                    Case "X"
                        newnode.NodeID = CharID.x
                    Case "Y"
                        newnode.NodeID = CharID.y
                    Case "Z"
                        newnode.NodeID = CharID.z
                End Select
                Return newnode.NodeID
            End Function

            ''' <summary>
            ''' Checks if given node has children
            ''' </summary>
            ''' <param name="Node"></param>
            ''' <returns></returns>
            Private Shared Function HasChildren(ByRef Node As TryTree) As Boolean
                Return If(Node.Children.Count > 0 = True, True, False)
            End Function

#End Region

#Region "Create"

            Private Shared Function MakeTrieTree() As TryTree
                Dim tree As New TryTree(True)

                tree.NodeData = "Root"
                tree.NodeID = CharID.StartChar
                Return tree
            End Function

#End Region


#Region "Frequency"
            ' Additional fields to store sequence frequency and overall frequency
            Private NodeSequenceFrequency As Integer
            Private totalNodeCount As Integer

            Private Structure VocabItem
                ' Additional fields to store sequence frequency and overall frequency
                Public NodeSequenceFrequency As Integer
                Public NodeIDS As List(Of Integer)
                Public NodeOverallFrequency As Integer
                Public Sub New(nodeSequenceFrequency As Integer,
                               nodeOverallFrequency As Integer)
                    If NodeIDS Is Nothing Then
                        Throw New ArgumentNullException(NameOf(NodeIDS))
                    End If

                    Me.NodeSequenceFrequency = nodeSequenceFrequency
                    Me.NodeOverallFrequency = nodeOverallFrequency
                    Me.NodeIDS = New List(Of Integer)
                End Sub
            End Structure
            ''' <summary>
            ''' Stores dictionary, frequencies
            ''' </summary>
            Private Vocabulary As Dictionary(Of String, VocabItem)
            Public Sub UpdateVocabulary(ByRef Term As String)
                totalNodeCount += 1
                Try
                    Dim node = Vocabulary(Term.ToLower)
                    node.NodeOverallFrequency += 1
                    Vocabulary.Remove(Term.ToLower)
                    Dim NewVocab As New VocabItem(NodeSequenceFrequency, node.NodeOverallFrequency)

                    Vocabulary.Add(Term, NewVocab)

                Catch ex As Exception
                    Dim NewVocab As New VocabItem(NodeSequenceFrequency, 1)


                    NewVocab.NodeIDS.Add(totalNodeCount)

                    Vocabulary.Add(Term.ToLower, NewVocab)
                End Try


            End Sub

            ''' <summary>
            ''' Adds char to Node(children) Returning the child
            ''' </summary>
            ''' <param name="CurrentNode">node containing children</param>
            ''' <param name="ChrStr">String to be added </param>
            ''' <param name="CharPos">this denotes the level of the node</param>
            ''' <returns></returns>
            Public Function AddStringToTrie(ByRef CurrentNode As TryTree, ByRef ChrStr As String, ByRef CharPos As Integer) As TryTree


                'start of tree
                Dim Text As String = ChrStr
                Dim returnNode As New TryTree
                Dim NewNode As New TryTree
                'Goto first node
                'does this node have siblings
                If TryTree.HasChildren(CurrentNode) = True Then
                    'Check children
                    If TryTree.CheckNodeExists(CurrentNode.Children, ChrStr) = False Then
                        'create a new node for char
                        NewNode = CreateNode(ChrStr, CurrentNode.NodeLevel + 1)
                        NewNode.NodeLevel = CharPos
                        'Add childnode
                        Me.NodeSequenceFrequency += 1 ' Increment sequence frequency
                        CurrentNode.Children.Add(NewNode)
                        UpdateVocabulary(ChrStr)
                        returnNode = TryTree.GetNode(CurrentNode.Children, ChrStr)
                    Else
                        returnNode = TryTree.GetNode(CurrentNode.Children, ChrStr)
                    End If
                Else
                    'If no silings then Create new node
                    'create a new node for char
                    NewNode = CreateNode(ChrStr, CurrentNode.NodeLevel + 1)
                    NewNode.NodeLevel = CharPos
                    'Add childnode
                    Me.NodeSequenceFrequency += 1 ' Increment sequence frequency
                    UpdateVocabulary(ChrStr)
                    CurrentNode.Children.Add(NewNode)
                    returnNode = TryTree.GetNode(CurrentNode.Children, ChrStr)
                End If

                Return returnNode
            End Function

#End Region


        End Class
        <Serializable>
        Public Class TrieTree
            Public Overridable Property root As Node

            Public Overridable Function MakeTrieTree() As TrieTree
                Dim tree As New TrieTree
                Dim iNode As New Node

                iNode.NodeData = "Root"
                iNode.NodeCharIndex = Node.CharID.StartChar
                tree.root = (iNode)
                Return tree
            End Function

            ''' <summary>
            ''' Inserts a string into the trie
            ''' </summary>
            ''' <param name="doc"></param>
            ''' <returns></returns>
            Public Function InsertByCharacters(ByRef Doc As String) As Node
                Return root.AddDocbyChars(root, Doc)
            End Function

            ''' <summary>
            ''' Inserts a string into the trie
            ''' </summary>
            ''' <param name="doc"></param>
            ''' <returns></returns>
            Public Function InsertByWord(ByRef Doc As String) As Node
                Return root.AddDocbyWord(root, Doc)
            End Function

            ''' <summary>
            ''' Inserts a string into the trie
            ''' </summary>
            ''' <param name="doc"></param>
            ''' <returns></returns>
            Public Function InsertIterativelyByCharacters(ByRef Doc As String) As Node
                Return root.AddDocItterativelyByCharacter(root, Doc)
            End Function

            ''' <summary>
            ''' Inserts a string into the trie
            ''' </summary>
            ''' <param name="doc"></param>
            ''' <returns></returns>
            Public Function InsertIterativelyByWord(ByRef Doc As String) As Node
                Return root.AddDocItterativelyByWord(root, Doc)
            End Function

        End Class
        <Serializable>
        Public Class FrequencyTrieTree
            Inherits TrieTree
            Public Shadows Property root As FrequencyNode

            Public Shadows Function MakeTrieTree() As FrequencyTrieTree
                Dim tree As New FrequencyTrieTree
                Dim iNode As New FrequencyNode

                iNode.NodeData = "Root"
                iNode.NodeCharIndex = Node.CharID.StartChar
                tree.root = (iNode)
                Return tree
            End Function

        End Class
        <Serializable>
        Public Class VocabularyTrieTree
            Inherits TrieTree
            Private Shadows WithEvents Root As VocabularyNode

            Public Shadows Function MakeTrieTree() As VocabularyTrieTree
                Dim tree As New VocabularyTrieTree
                Dim iNode As New VocabularyNode

                iNode.NodeData = "Root"
                iNode.NodeCharIndex = Node.CharID.StartChar
                tree.Root = (iNode)
                Return tree
            End Function

            Private Sub TreeVocabularyUpdated(ByRef sender As VocabularyNode, Data As VocabularyNode) Handles Root.VocabularyUpdated
                UpdateVocabulary(Data)
            End Sub

            ''' <summary>
            ''' (Text,Frequency)
            ''' Frequency of term in Vocabulary
            ''' </summary>
            ''' <returns>Frequency</returns>
            Public ReadOnly Property Vocabulary As Dictionary(Of String, VocabItem)

            Public Sub UpdateVocabulary(ByRef Term As Node)

                Try
                    Dim nodeVocabItem = Vocabulary(Term.NodeText.ToUpper)
                    nodeVocabItem.NodeIDS.Add(Term.NodeID)
                    nodeVocabItem.IncrementFrequency()
                    Vocabulary.Remove(Term.NodeText.ToUpper)
                    Vocabulary.Add(Term.NodeText.ToUpper, nodeVocabItem)
                Catch ex As Exception
                    Dim NewVocab As New VocabItem(Term.NodeID)
                    Vocabulary.Add(Term.NodeText.ToUpper, NewVocab)
                End Try

            End Sub

        End Class
        Namespace BeliefTree
            <Serializable>
            Public Class ConditionalProbabilityTable
                Public Property Node As BeliefNode
                Public Property Values As Dictionary(Of List(Of String), Double)

                Public Sub New(node As BeliefNode)
                    Me.Node = node
                    Values = New Dictionary(Of List(Of String), Double)
                End Sub

                Public Sub SetEntry(parentStates As List(Of String), value As Double)
                    Values(parentStates) = value
                End Sub
            End Class
            <Serializable>
            Public Class InferenceEngine
                Public Sub New(network As BeliefNetwork)
                    Me.Network = network
                End Sub

                Public Property Network As BeliefNetwork

                Public Function CalculateConditionalProbability(node As BeliefNode, state As String) As Double
                    Dim totalProbability As Double = 0.0
                    Dim parentNodes = node.Parents

                    For Each parentState In CartesianProduct(parentNodes.Select(Function(n) n.States))
                        Dim evidence As New Dictionary(Of BeliefNode, String)
                        For i = 0 To parentNodes.Count - 1
                            evidence(parentNodes(i)) = parentState(i)
                        Next

                        Dim jointProbability As Double = CalculateJointProbability(evidence)
                        totalProbability += jointProbability
                    Next

                    Dim evidenceWithState As New Dictionary(Of BeliefNode, String)
                    evidenceWithState(node) = state

                    Dim conditionalProbability = CalculateJointProbability(evidenceWithState) / totalProbability
                    Return conditionalProbability
                End Function

                Private Function CalculateJointProbability(evidence As Dictionary(Of BeliefNode, String)) As Double
                    Dim jointProbability As Double = 1.0

                    For Each node In Network.Nodes
                        Dim nodeProbability As Double

                        If evidence.ContainsKey(node) Then
                            Dim parentStates = node.Parents.Select(Function(parent) evidence(parent))
                            nodeProbability = node.CPT.Values(parentStates.ToList())
                        Else
                            Dim parentStates = node.Parents.Select(Function(parent) evidence(parent))
                            nodeProbability = node.CPT.Values(parentStates.ToList())
                        End If

                        jointProbability *= nodeProbability
                    Next

                    Return jointProbability
                End Function

                Private Iterator Function CartesianProduct(sequences As IEnumerable(Of IEnumerable(Of String))) As IEnumerable(Of List(Of String))
                    Dim enumerators = sequences.Select(Function(seq) seq.GetEnumerator()).ToArray()
                    Dim values = New List(Of String)(enumerators.Length)

                    While True
                        values.Clear()

                        For i = 0 To enumerators.Length - 1
                            Dim enumerator = enumerators(i)
                            If Not enumerator.MoveNext() Then
                                enumerator.Reset()
                                enumerator.MoveNext()
                            End If
                            values.Add(enumerator.Current)
                        Next

                        Yield values.ToList()
                    End While
                End Function
            End Class
            <Serializable>
            Public Class BeliefNetwork
                Public Property Nodes As List(Of BeliefNode)
                Public Sub LoadTrainingData(trainingData As Dictionary(Of String, Dictionary(Of List(Of String), Double)))
                    For Each entry In trainingData
                        Dim nodeName As String = entry.Key
                        Dim values As Dictionary(Of List(Of String), Double) = entry.Value

                        DefineCPT(nodeName, values)
                    Next
                End Sub

                Public Function CreateEvidence(nodeName As String, state As String) As Dictionary(Of BeliefNode, String)
                    Dim evidence As New Dictionary(Of BeliefNode, String)
                    Dim node As BeliefNode = Nodes.Find(Function(n) n.Name = nodeName)
                    evidence.Add(node, state)
                    Return evidence
                End Function

                Public Function GetNodeByName(nodeName As String) As BeliefNode
                    Return Nodes.Find(Function(n) n.Name = nodeName)
                End Function

                Public Function PredictWithEvidence(targetNodeName As String, evidence As Dictionary(Of BeliefNode, String)) As String
                    Dim targetNode As BeliefNode = GetNodeByName(targetNodeName)
                    Return Predict(targetNode, evidence)
                End Function
                Public Sub LoadTrainingDataFromFile(filePath As String)
                    Dim trainingData As Dictionary(Of String, Dictionary(Of List(Of String), Double)) = LoadTrainingData(filePath)
                    For Each entry In trainingData
                        Dim nodeName As String = entry.Key
                        Dim values As Dictionary(Of List(Of String), Double) = entry.Value

                        DefineCPT(nodeName, values)
                    Next
                End Sub
                Public Sub ExportToFile(filePath As String)
                    Dim lines As New List(Of String)

                    For Each node In Nodes
                        lines.Add(node.Name)
                        For Each state In node.States
                            If node.Parents.Count > 0 Then
                                Dim parentStates As New List(Of String)()
                                For Each parent In node.Parents
                                    parentStates.Add(parent.Name)
                                Next
                                parentStates.Add(state)
                                lines.Add(String.Join(" ", parentStates) & " " & node.CPT.Values(parentStates))
                            Else
                                lines.Add(state & " " & node.CPT.Values(New List(Of String)()))
                            End If
                        Next
                    Next

                    File.WriteAllLines(filePath, lines)
                    Console.WriteLine("Network exported to " & filePath)
                End Sub
                Public Sub DisplayAsTree()
                    Dim form As New Form()
                    Dim treeView As New TreeView()
                    treeView.Dock = DockStyle.Fill
                    form.Controls.Add(treeView)

                    For Each node In Nodes
                        Dim treeNode As New TreeNode(node.Name)

                        If node.Parents.Count > 0 Then
                            Dim parentNodes As New List(Of String)()
                            For Each parent In node.Parents
                                parentNodes.Add(parent.Name)
                            Next

                            Dim parentNode As TreeNode = FindOrCreateParentNode(treeView.Nodes, parentNodes)
                            parentNode.Nodes.Add(treeNode)
                        Else
                            treeView.Nodes.Add(treeNode)
                        End If

                        For Each state In node.States
                            Dim stateNode As New TreeNode(state & " (" & node.CPT.Values(New List(Of String) From {state}) & ")")
                            treeNode.Nodes.Add(stateNode)
                        Next
                    Next

                    Application.Run(form)
                End Sub

                Public Shared Sub DisplayAsTree(ByRef Network As BeliefNetwork)
                    Dim form As New Form()
                    Dim treeView As New TreeView()
                    treeView.Dock = DockStyle.Fill
                    form.Controls.Add(treeView)

                    For Each node In Network.Nodes
                        Dim treeNode As New TreeNode(node.Name)

                        If node.Parents.Count > 0 Then
                            Dim parentNodes As New List(Of String)()
                            For Each parent In node.Parents
                                parentNodes.Add(parent.Name)
                            Next

                            Dim parentNode As TreeNode = Network.FindOrCreateParentNode(treeView.Nodes, parentNodes)
                            parentNode.Nodes.Add(treeNode)
                        Else
                            treeView.Nodes.Add(treeNode)
                        End If

                        For Each state In node.States
                            Dim stateNode As New TreeNode(state & " (" & node.CPT.Values(New List(Of String) From {state}) & ")")
                            treeNode.Nodes.Add(stateNode)
                        Next
                    Next

                    Application.Run(form)
                End Sub


                Private Function FindOrCreateParentNode(collection As TreeNodeCollection, parentNodes As List(Of String)) As TreeNode
                    Dim parentNode As TreeNode = Nothing

                    For Each parentName In parentNodes
                        Dim node As TreeNode = collection.Find(parentName, False).FirstOrDefault()

                        If node IsNot Nothing Then
                            collection = node.Nodes
                            parentNode = node
                        Else
                            Dim newNode As New TreeNode(parentName)
                            If parentNode Is Nothing Then
                                collection.Add(newNode)
                            Else
                                parentNode.Nodes.Add(newNode)
                            End If
                            collection = newNode.Nodes
                            parentNode = newNode
                        End If
                    Next

                    Return parentNode
                End Function

                Public Shared Function LoadTrainingData(filePath As String) As Dictionary(Of String, Dictionary(Of List(Of String), Double))
                    Dim trainingData As New Dictionary(Of String, Dictionary(Of List(Of String), Double))()

                    If File.Exists(filePath) Then
                        Dim lines As String() = File.ReadAllLines(filePath)
                        Dim currentEntry As String = Nothing
                        Dim currentCPT As New Dictionary(Of List(Of String), Double)()

                        For Each line In lines
                            Dim parts As String() = Split(line, " "c, StringSplitOptions.RemoveEmptyEntries)

                            If parts.Length = 1 Then
                                ' Start of a new entry
                                If currentEntry IsNot Nothing Then
                                    trainingData.Add(currentEntry, currentCPT)
                                    currentCPT = New Dictionary(Of List(Of String), Double)()
                                End If

                                currentEntry = parts(0)
                            ElseIf parts.Length = 2 Then
                                ' CPT entry
                                Dim state As String = parts(0)
                                Dim probability As Double = Double.Parse(parts(1))
                                currentCPT.Add(New List(Of String) From {state}, probability)
                            ElseIf parts.Length > 2 Then
                                ' CPT entry with parent states
                                Dim states As New List(Of String)(parts.Length - 1)
                                For i As Integer = 0 To parts.Length - 2
                                    states.Add(parts(i))
                                Next
                                Dim probability As Double = Double.Parse(parts(parts.Length - 1))
                                currentCPT.Add(states, probability)
                            End If
                        Next

                        ' Add the last entry
                        If currentEntry IsNot Nothing Then
                            trainingData.Add(currentEntry, currentCPT)
                        End If
                    Else
                        Console.WriteLine("Training data file not found.")
                    End If

                    Return trainingData
                End Function
                Public Sub New()
                    Nodes = New List(Of BeliefNode)()
                End Sub

                Public Sub AddNode(node As BeliefNode)
                    Nodes.Add(node)
                End Sub
                Public Function Predict(targetNode As BeliefNode, evidence As Dictionary(Of BeliefNode, String)) As String
                    Dim engine As New InferenceEngine(Me)
                    Dim conditionalProbability As Double = engine.CalculateConditionalProbability(targetNode, evidence(targetNode))
                    Dim predictedState As String = If(conditionalProbability > 0.5, evidence(targetNode), GetOppositeState(targetNode, evidence(targetNode)))
                    Return predictedState
                End Function

                Private Function GetOppositeState(node As BeliefNode, state As String) As String
                    Return node.States.Find(Function(s) s <> state)
                End Function

                Public Sub DefineCPT(nodeName As String, values As Dictionary(Of List(Of String), Double))
                    Dim node = Nodes.Find(Function(n) n.Name = nodeName)
                    Dim cpt As New ConditionalProbabilityTable(node)
                    For Each entry In values
                        cpt.SetEntry(entry.Key, entry.Value)
                    Next
                    node.CPT = cpt
                End Sub
                Public Sub DisplayNetworkStructure()
                    Console.WriteLine("Network Structure:")
                    For Each node In Nodes
                        Console.WriteLine("Node: " & node.Name)
                        Console.WriteLine("Parents: " & String.Join(", ", node.Parents.Select(Function(parent) parent.Name)))
                        Console.WriteLine("CPT:")
                        For Each entry In node.CPT.Values
                            Console.WriteLine("  P(" & node.Name & " = " & String.Join(", ", entry.Key) & ") = " & entry.Value)
                        Next
                        Console.WriteLine()
                    Next
                End Sub
                Public Sub AddEdge(parentNode As BeliefNode, childNode As BeliefNode)
                    childNode.Parents.Add(parentNode)
                End Sub
            End Class



        End Namespace
        ''' <summary>
        ''' All nodes in a binary Tree have Left and Right nodes Nodes are added to the end of the tree
        ''' organized then the tree can be reorganized the rules are such that the lowest numbers are
        ''' always on the left and the highest numbers are on the right
        ''' </summary>
        <Serializable>
        Public Class BinaryTree

            ''' <summary>
            ''' Data to be held in Node
            ''' </summary>
            Public Data As Integer

            Public Left As BinaryTree

            ''' <summary>
            ''' String Tree
            ''' </summary>
            Public PRN As String = ""

            Public Right As BinaryTree

            ''' <summary>
            ''' TreeControl Tree (once tree has been printed then the view Will Be populated)
            ''' </summary>
            Public Tree As System.Windows.Forms.TreeView

            Public Sub New(ByVal Data As Integer)
                Me.Data = Data
            End Sub

            Public Property Prnt As String
                Get
                    Return PRN

                End Get
                Set(value As String)
                    PRN = value
                End Set
            End Property

            Public Function Contains(ByRef ExistingData As Integer) As Boolean
                Return If(ExistingData = Me.Data, True, If(ExistingData < Data, If(Left Is Nothing, False, Left.Contains(ExistingData)), If(Right Is Nothing, False, Right.Contains(ExistingData))))
            End Function

            ''' <summary>
            ''' Inserts new data into tree and adds node in appropriate place
            ''' </summary>
            ''' <param name="NewData"></param>
            Public Sub insert(ByVal NewData As Integer)
                If NewData <= Data Then
                    If Left IsNot Nothing Then
                        Left = New BinaryTree(NewData)
                    Else
                        Left.insert(NewData)
                    End If
                Else
                    If Right IsNot Nothing Then
                        Right = New BinaryTree(NewData)
                    Else
                        Right.insert(NewData)
                    End If
                End If

            End Sub

            ''' <summary>
            ''' Prints in order ABC Left then Root then Right B=Root A=Left C=Right
            ''' </summary>
            Public Sub PrintInOrder()
                If Left IsNot Nothing Then
                    Left.PrintInOrder()
                End If

                Prnt &= "Node :" & Me.Data & vbNewLine
                Dim nde As New System.Windows.Forms.TreeNode
                nde.Text = "Node :" & Me.Data & vbNewLine
                Tree.Nodes.Add(nde)
                If Right IsNot Nothing Then
                    Right.PrintInOrder()
                End If

            End Sub

            ''' <summary>
            ''' Prints in order ACB Left then Right Then Root B=Root A=Left C=Right
            ''' </summary>
            Public Sub PrintPostOrder()
                'Left Nodes
                If Left IsNot Nothing Then
                    Left.PrintInOrder()
                End If
                'Right nodes
                If Right IsNot Nothing Then
                    Right.PrintInOrder()
                End If

                'Root
                Prnt &= "Node :" & Me.Data & vbNewLine
                Dim nde As New System.Windows.Forms.TreeNode
                nde.Text = "Node :" & Me.Data & vbNewLine
                Tree.Nodes.Add(nde)
            End Sub

            ''' <summary>
            ''' Prints in order BAC Root then left then right B=Root A=Left C=Right
            ''' </summary>
            Public Sub PrintPreOrder()
                'Root
                Prnt &= "Node :" & Me.Data & vbNewLine
                Dim nde As New System.Windows.Forms.TreeNode
                nde.Text = "Node :" & Me.Data & vbNewLine
                Tree.Nodes.Add(nde)
                'Right nodes
                If Right IsNot Nothing Then
                    Right.PrintInOrder()
                End If
                'Left Nodes
                If Left IsNot Nothing Then
                    Left.PrintInOrder()
                End If
            End Sub

        End Class



    End Namespace
    ''' <summary>
    ''' This object is created when the Vocabulary item is generated.
    ''' therefore it is Connected to the data which it is attached to
    ''' so there is no need to identify the data or restore the same term
    ''' in here reducing the overall footprint
    ''' of the impact of vocabulary on top of a fully loaded tree.
    ''' This Vocab Item can be extended to hold Term Specific Information such as definition,
    ''' when if held in the node would cause repetitive information being held.
    ''' This also enables for the Vocabulary to be used as a custom Dictionary object
    ''' </summary>
    <Serializable>
    Public Structure VocabItem

        ''' <summary>
        ''' Frequency of term in the Tree
        ''' </summary>
        Public Frequency As Integer

        Private iNodeIDS As List(Of Integer)

        ''' <summary>
        ''' Create New VocabItem, it will be intialized with assert(value) frequency of 1
        ''' </summary>
        ''' <param name="NodeID">the node id being added</param>
        Public Sub New(NodeID As Integer)

            Me.Frequency = 1
            Me.iNodeIDS = New List(Of Integer)
            iNodeIDS.Add(NodeID)
        End Sub

        ''' <summary>
        ''' as list of nodes which contain the term/Token(nodeText)
        ''' by traversing the tree to the identified node ,
        ''' its sequence frequency and context nodes can be obtained
        ''' by traversing up or down the tree the required depth
        ''' </summary>
        Public ReadOnly Property NodeIDS As List(Of Integer)
            Get
                Return iNodeIDS
            End Get
        End Property

        Public Sub AddNodeID(ByRef ID As Integer)
            If iNodeIDS.Contains(ID) Then
            Else
                iNodeIDS.Add(ID)
            End If
        End Sub

        ''' <summary>
        ''' Increments frequency by 1
        ''' </summary>
        Public Sub IncrementFrequency()
            Frequency += 1
        End Sub

        Public Sub RemoveNodeID(ByRef ID As Integer)
            iNodeIDS.Remove(ID)
        End Sub

    End Structure
    ''' <summary>
    ''' Returns a list WordGram Probability Given a Sequence of Tokens
    ''' </summary>
    <Serializable>
    Public Class Predict

        ''' <summary>
        ''' word gram Value
        ''' </summary>
        Public n As Integer = 1

        ' You can adjust the temperature parameter for tuning the distribution
        Public temperature As Double = 1.0

        Private wordgramCounts As New Dictionary(Of List(Of String), Integer)
        Private wordgramProbabilities As New Dictionary(Of List(Of String), Double)

        ''' <summary>
        ''' Generates a sentence based on the stored data
        ''' </summary>
        ''' <returns></returns>
        Public Function ForwardsSentence() As String
            Dim sentence As New List(Of String)
            Dim random As New Random()

            ' Start the sentence with a random wordgram
            Dim randomIndex As Integer = random.Next(0, wordgramCounts.Count)
            Dim currentWordgram As List(Of String) = wordgramCounts.Keys(randomIndex)
            sentence.AddRange(currentWordgram)

            ' Generate subsequent words based on wordgram probabilities
            While wordgramCounts.ContainsKey(currentWordgram)
                Dim nextWord As String = ForwardsWord(currentWordgram)
                If nextWord = "" Then
                    Exit While
                End If
                sentence.Add(nextWord)

                ' Backoff to lower-order wordgrams if necessary
                If currentWordgram.Count > 1 Then
                    currentWordgram.RemoveAt(0)
                Else
                    Exit While
                End If
                currentWordgram.Add(nextWord)
            End While

            Return String.Join(" ", sentence)
        End Function

        Public Function Train(trainingPaths As List(Of List(Of String))) As Dictionary(Of List(Of String), Double)

            ' Preprocess training data and tokenize into wordgrams
            Dim wordgrams As New List(Of List(Of String))
            For Each path As List(Of String) In trainingPaths
                For i As Integer = 0 To path.Count - n
                    Dim wordgram As List(Of String) = path.Skip(i).Take(n).ToList()
                    wordgrams.Add(wordgram)
                Next
            Next

            ' Count wordgrams
            For Each wordgram As List(Of String) In wordgrams
                If wordgramCounts.ContainsKey(wordgram) Then
                    wordgramCounts(wordgram) += 1
                Else
                    wordgramCounts.Add(wordgram, 1)
                End If
            Next

            ' Calculate wordgram probabilities based on frequency-based distribution
            For Each wordgram As List(Of String) In wordgramCounts.Keys
                Dim count As Integer = wordgramCounts(wordgram)
                Dim order As Integer = wordgram.Count

                ' Calculate the frequency threshold for higher-order n-grams
                Dim frequencyThreshold As Integer = 5 ' Set your desired threshold
                If order = n AndAlso count >= frequencyThreshold Then
                    wordgramProbabilities.Add(wordgram, count)
                ElseIf order < n AndAlso count >= frequencyThreshold Then
                    ' Assign the frequency to lower-order n-grams
                    Dim lowerOrderWordgram As List(Of String) = wordgram.Skip(1).ToList()
                    If wordgramProbabilities.ContainsKey(lowerOrderWordgram) Then
                        wordgramProbabilities(lowerOrderWordgram) += count
                    Else
                        wordgramProbabilities.Add(lowerOrderWordgram, count)
                    End If
                End If
            Next

            ' Normalize probabilities within each order
            For order As Integer = 1 To n
                Dim totalProbability As Double = 0
                For Each wordgram As List(Of String) In wordgramProbabilities.Keys.ToList()
                    If wordgram.Count = order Then
                        totalProbability += wordgramProbabilities(wordgram)
                    End If
                Next
                For Each wordgram As List(Of String) In wordgramProbabilities.Keys.ToList()
                    If wordgram.Count = order Then
                        wordgramProbabilities(wordgram) /= totalProbability
                    End If
                Next
            Next
            CalculateSoftmaxProbabilities()
            Return wordgramProbabilities
        End Function

        Public Function ForwardsWord(wordgram As List(Of String)) As String
            Dim random As New Random()
            Dim candidates As New List(Of String)
            Dim probabilities As New List(Of Double)

            ' Collect candidate words and their probabilities
            For Each candidateWordgram As List(Of String) In wordgramCounts.Keys
                If candidateWordgram.GetRange(0, n - 1).SequenceEqual(wordgram) Then
                    Dim candidateWord As String = candidateWordgram.Last()
                    Dim probability As Double = wordgramProbabilities(candidateWordgram)
                    candidates.Add(candidateWord)
                    probabilities.Add(probability)
                End If
            Next

            ' Randomly select a candidate word based on probabilities
            Dim totalProbability As Double = probabilities.Sum()
            Dim randomValue As Double = random.NextDouble() * totalProbability
            Dim cumulativeProbability As Double = 0

            For i As Integer = 0 To candidates.Count - 1
                cumulativeProbability += probabilities(i)
                If randomValue <= cumulativeProbability Then
                    Return candidates(i)
                End If
            Next

            Return ""
        End Function

        Private Sub CalculateSoftmaxProbabilities()
            For Each wordgram As List(Of String) In wordgramCounts.Keys.ToList()
                Dim count As Integer = wordgramCounts(wordgram)
                Dim order As Integer = wordgram.Count

                ' Calculate the frequency threshold for higher-order n-grams
                Dim frequencyThreshold As Integer = 5 ' Set your desired threshold
                If order = n AndAlso count >= frequencyThreshold Then
                    wordgramProbabilities.Add(wordgram, Softmax(count))
                ElseIf order < n AndAlso count >= frequencyThreshold Then
                    ' Assign the softmax probability to lower-order n-grams
                    Dim lowerOrderWordgram As List(Of String) = wordgram.Skip(1).ToList()
                    If wordgramProbabilities.ContainsKey(lowerOrderWordgram) Then
                        wordgramProbabilities(lowerOrderWordgram) = Softmax(count)
                    Else
                        wordgramProbabilities.Add(lowerOrderWordgram, Softmax(count))
                    End If
                End If
            Next
        End Sub

        Private Function Softmax(x As Integer) As Double
            ' Apply softmax function to the count to get normalized probability

            Dim exponentiated As Double = Math.Exp(x / temperature)
            Return exponentiated
        End Function

    End Class
    Namespace Nodes
        <Serializable>
        Public Class BeliefNode
            Public Property Name As String
            Public Property States As List(Of String)
            Public Property Parents As List(Of BeliefNode)
            Public Property CPT As ConditionalProbabilityTable

            Public Sub New(name As String, states As List(Of String))
                Me.Name = name
                Me.States = states
                Parents = New List(Of BeliefNode)
            End Sub
        End Class
        <Serializable>
        Public Class Node





            ''' <summary>
            ''' Theses are essentially the branches of the Tree....
            ''' if there are no children then the node is a leaf.
            ''' Denoted by the StopCharacter NodeID. or "StopChar" NodeData.
            ''' </summary>
            Public Children As List(Of Node)

            ''' <summary>
            ''' Used To hold CharacterStr (tries) Also Useful for Creating ID for node;
            ''' : (a String) can be used to store a specific Pathway :(legacy Functionality)
            ''' </summary>
            Public NodeData As String

            ''' <summary>
            ''' Unique ID for Node
            ''' </summary>
            Public NodeID As Integer

            ''' <summary>
            ''' the level denotes also how many vertices before returning to the root.
            ''' In a Trie Tree the first node is blank and not included therefore the Vertices are level-1
            ''' </summary>
            Public NodeLevel As Integer

            ''' <summary>
            ''' Text Held in the node
            ''' </summary>
            Public NodeText As String

            ''' <summary>
            ''' Each NodeID: is specific to Its level this id is generated by the tree:
            ''' used for alphabetically aligned trees and sorting methodologies
            ''' </summary>
            Public NodeCharIndex As CharID

            ''' <summary>
            ''' Each Set of Nodes has only 26 ID's ID 0 = stop
            ''' this can be used to create alphabetically aligned trees
            ''' </summary>
            Public Enum CharID

                StartChar = 0
                a = 1
                b = 2
                c = 3
                d = 4
                e = 5
                f = 6
                g = 7
                h = 8
                i = 9
                j = 10
                k = 11
                l = 12
                m = 13
                n = 14
                o = 15
                p = 16
                q = 17
                r = 18
                s = 19
                t = 20
                u = 21
                v = 22
                w = 23
                x = 24
                y = 25
                z = 26
                StopChar = 27
            End Enum

            ''' <summary>
            ''' Adds string to given trie
            ''' </summary>
            ''' <param name="Tree">Node from which to enter the char</param>
            ''' <param name="doc"></param>
            ''' <returns></returns>
            Public Function AddDocbyChars(ByRef Tree As Node, doc As String) As Node
                Dim curr As Node = Tree
                Dim Pos As Integer = 0

                For Each chr As Char In doc
                    Dim ID = NumberOfNodes() + 1
                    Pos += 1
                    curr = AddStringToTrie(curr, chr, Pos, ID)
                Next
                curr = AddStringToTrie(curr, "StopChar", Pos + 1, NumberOfNodes() + 1)
                Return Tree
            End Function

            ''' <summary>
            ''' Adds string to given trie
            ''' </summary>
            ''' <param name="Tree">Node From which to enter the word</param>
            ''' <param name="doc"></param>
            ''' <returns></returns>
            Public Function AddDocbyWord(ByRef Tree As Node, Doc As String) As Node
                Dim curr As Node = Tree
                Dim Pos As Integer = 0
                For Each chr As String In Doc.Split(" ")
                    Pos += 1
                    Dim ID = NumberOfNodes() + 1
                    curr = AddStringToTrie(curr, chr, Pos, ID)
                Next
                curr = AddStringToTrie(curr, "StopChar", Pos + 1, NumberOfNodes() + 1)
                Return Tree
            End Function

            ''' <summary>
            ''' Add characters Iteratively
            ''' CAT
            ''' AT
            ''' T
            ''' </summary>
            ''' <param name="doc"></param>
            ''' <param name="TrieTree"></param>
            Public Function AddDocItterativelyByCharacter(ByRef TrieTree As Node, ByRef Doc As String) As Node
                'AddWord
                For i = 1 To Doc.Length
                    InsertByCharacters(Doc)
                    Doc = Doc.Remove(0, 1)
                Next
                Return TrieTree
            End Function

            ''' <summary>
            ''' Add characters Iteratively
            ''' CAT
            ''' AT
            ''' T
            ''' </summary>
            ''' <param name="doc"></param>
            ''' <param name="TrieTree"></param>
            Public Function AddDocItterativelyByWord(ByRef TrieTree As Node, ByRef Doc As String) As Node
                'AddWord
                Dim x = Doc.Split(" ")
                For Each item As String In x
                    InsertByWord(Doc)
                    If Doc.Length > item.Length + 1 = True Then
                        Doc = Doc.Remove(0, item.Length + 1)
                    Else
                        Doc = ""
                    End If
                Next
                Return TrieTree
            End Function

            ''' <summary>
            ''' checks if node exists in child nodes (used for trie trees (String added is the key and the data)
            ''' </summary>
            ''' <param name="Nodedata">Char string used as identifier</param>
            ''' <returns></returns>
            Public Function CheckNodeExists(ByRef Nodedata As String) As Boolean
                'Check node does not exist
                Dim found As Boolean = False
                For Each mNode As Node In Children
                    If mNode.NodeData = Nodedata Then
                        found = True
                    Else
                    End If
                Next
                Return found
            End Function

            ''' <summary>
            ''' Returns true if string is contained in trie (prefix) not as Word
            ''' </summary>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Function CheckPrefix(ByRef Str As String) As Boolean
                Str = Str.ToUpper
                Dim CurrentNode As Node = Me
                Dim found As Boolean = False

                Dim Pos As Integer = 0
                For Each chrStr As Char In Str
                    Pos += 1

                    'Check Chars
                    If CurrentNode.CheckNodeExists(chrStr) = True Then
                        CurrentNode = CurrentNode.GetNode(chrStr)
                        found = True
                    Else
                        found = False
                    End If
                Next
                Return found
            End Function

            ''' <summary>
            ''' Returns number of Nodes in tree
            ''' </summary>
            ''' <returns></returns>
            Public Function CountNodes(ByRef CurrentCount As Integer) As Integer
                Dim count As Integer = CurrentCount
                For Each child In Me.Children
                    count += 1
                    count = child.CountNodes(count)
                Next
                Return count
            End Function

            ''' <summary>
            ''' Counts Complete Pathways
            ''' </summary>
            ''' <param name="CurrentCount"></param>
            ''' <returns></returns>
            Public Function CountPaths(ByRef CurrentCount As Integer) As Integer
                Dim count As Integer = CurrentCount
                For Each child In Me.Children
                    If child.NodeID = CharID.StopChar = True Then
                        count += 1

                    End If
                    count = child.CountPaths(count)
                Next

                Return count
            End Function

            ''' <summary>
            ''' Returns Matched Node to sender (used to recures children)
            ''' </summary>
            ''' <param name="NodeData"></param>
            ''' <returns></returns>
            Public Function GetNode(ByRef NodeData As String) As Node
                Dim Foundnode As New Node
                For Each item In Children
                    If item.NodeData = NodeData Then
                        Foundnode = item
                    Else
                    End If
                Next
                Return Foundnode
            End Function

            Public Function GetPathsToLeafNodes() As List(Of List(Of String))
                Dim paths As New List(Of List(Of String))
                If Not Me.HasChildren() Then
                    ' Leaf node reached, return a path with single word
                    paths.Add(New List(Of String) From {Me.NodeData})
                Else
                    ' Traverse children and collect paths
                    For Each child In Me.Children
                        Dim childPaths As List(Of List(Of String)) = child.GetPathsToLeafNodes()
                        For Each path In childPaths
                            paths.Add(New List(Of String)({Me.NodeData}).Concat(path).ToList())
                        Next
                    Next
                End If
                Return paths
            End Function

            ''' <summary>
            ''' Checks if given node has children
            ''' </summary>
            ''' <returns></returns>
            Public Function HasChildren() As Boolean
                Return If(Children.Count > 0 = True, True, False)
            End Function

            ''' <summary>
            ''' Inserts a string into the trie
            ''' </summary>
            ''' <param name="doc"></param>
            ''' <returns></returns>
            Public Function InsertByCharacters(ByRef Doc As String) As Node
                Return AddDocbyChars(Me, Doc)
            End Function

            ''' <summary>
            ''' Inserts a string into the trie
            ''' </summary>
            ''' <param name="doc"></param>
            ''' <returns></returns>
            Public Function InsertByWord(ByRef Doc As String) As Node
                Return AddDocbyWord(Me, Doc)
            End Function

            ''' <summary>
            ''' Returns deepest level
            ''' </summary>
            ''' <returns></returns>
            Public Function LowestLevel() As Integer
                'Gets the level for node
                Dim Level As Integer = Me.NodeLevel

                'Recurses children
                For Each child In Me.Children
                    If Level < child.LowestLevel = True Then
                        Level = child.LowestLevel
                    End If
                Next
                'The loop should finish at the lowest level
                Return Level
            End Function

            ''' <summary>
            ''' Returns Number of Nodes
            ''' </summary>
            ''' <returns></returns>
            Public Function NumberOfNodes() As Integer
                Dim Count As Integer = 0
                'Old Method
                'For Each child In Me.Children
                '    Count += child.NumberOfNodes
                'Next

                Count = CountNodes(Count)
                Return Count
            End Function

            Public Function ToJson() As String
                Dim Converter As New JavaScriptSerializer
                Return Converter.Serialize(Me)

            End Function

            ''' <summary>
            ''' Returns a TreeViewControl with the Contents of the Trie:
            ''' </summary>
            ''' <returns></returns>
            Public Function ToView() As System.Windows.Forms.TreeNode
                Dim nde As New System.Windows.Forms.TreeNode
                nde.Text = Me.NodeData.ToString.ToUpper & vbNewLine &
                "(" & Me.NodeLevel & ")" & vbNewLine

                For Each child In Me.Children
                    nde.Nodes.Add(child.ToView)

                Next

                Return nde

            End Function

            ''' <summary>
            ''' Generates an ID from NodeData
            ''' </summary>
            ''' <param name="Nodedata">Character string for node</param>
            ''' <returns></returns>
            Public Function GenerateNodeCharIndex(ByRef Nodedata As String) As CharID
                Dim newnode As New Node
                'SET ID for node
                Select Case Nodedata.ToUpper
                    Case "STOPCHAR"
                        newnode.NodeID = CharID.StopChar
                    Case "A"
                        newnode.NodeID = CharID.a
                    Case "B"
                        newnode.NodeID = CharID.b
                    Case "C"
                        newnode.NodeID = CharID.c
                    Case "D"
                        newnode.NodeID = CharID.d
                    Case "E"
                        newnode.NodeID = CharID.e
                    Case "F"
                        newnode.NodeID = CharID.f
                    Case "G"
                        newnode.NodeID = CharID.g
                    Case "H"
                        newnode.NodeID = CharID.h
                    Case "I"
                        newnode.NodeID = CharID.i
                    Case "J"
                        newnode.NodeID = CharID.j
                    Case "K"
                        newnode.NodeID = CharID.k
                    Case "L"
                        newnode.NodeID = CharID.l
                    Case "M"
                        newnode.NodeID = CharID.m
                    Case "N"
                        newnode.NodeID = CharID.n
                    Case "O"
                        newnode.NodeID = CharID.o
                    Case "P"
                        newnode.NodeID = CharID.p
                    Case "Q"
                        newnode.NodeID = CharID.q
                    Case "R"
                        newnode.NodeID = CharID.r
                    Case "S"
                        newnode.NodeID = CharID.s
                    Case "T"
                        newnode.NodeID = CharID.t
                    Case "U"
                        newnode.NodeID = CharID.u
                    Case "V"
                        newnode.NodeID = CharID.v
                    Case "W"
                        newnode.NodeID = CharID.w
                    Case "X"
                        newnode.NodeID = CharID.x
                    Case "Y"
                        newnode.NodeID = CharID.y
                    Case "Z"
                        newnode.NodeID = CharID.z
                End Select
                Return newnode.NodeID
            End Function

            ''' <summary>
            ''' creates a new node
            ''' </summary>
            ''' <param name="NodeData">Character to be added</param>
            Public Function CreateNode(ByRef NodeData As String, ByRef Level As Integer, ByRef ID As Integer) As Node

                'Create node
                Dim NewNode As New Node
                NewNode.NodeData = NodeData
                'create id
                NewNode.NodeID = ID
                NewNode.NodeLevel = Level

                NewNode.NodeCharIndex = GenerateNodeCharIndex(NodeData)
                Return NewNode
            End Function

            ''' <summary>
            ''' Adds char to Node(children) Returning the child
            ''' </summary>
            ''' <param name="CurrentNode">node containing children</param>
            ''' <param name="ChrStr">String to be added </param>
            ''' <param name="CharPos">this denotes the level of the node</param>
            ''' <returns></returns>
            Public Function AddStringToTrie(ByRef CurrentNode As Node, ByRef ChrStr As String, ByRef CharPos As Integer, NewNodeID As Integer) As Node

                'start of tree
                Dim Text As String = ChrStr
                Dim returnNode As New Node
                Dim NewNode As New Node
                'Goto first (root)
                'does this node have siblings
                If CurrentNode.HasChildren() = True Then
                    'Check children
                    If CurrentNode.CheckNodeExists(ChrStr) = False Then
                        'create a new node for char
                        NewNode = CreateNode(ChrStr, CurrentNode.NodeLevel + 1, NewNodeID)
                        NewNode.NodeLevel = CharPos
                        'Add childnode
                        CurrentNode.Children.Add(NewNode)

                        returnNode = GetNode(ChrStr)
                    Else

                        returnNode = GetNode(ChrStr)
                    End If
                Else
                    'If no siblings then Create new node
                    'create a new node for char
                    NewNode = CreateNode(ChrStr, CurrentNode.NodeLevel + 1, NewNodeID)
                    NewNode.NodeLevel = CharPos
                    'Add childnode

                    CurrentNode.Children.Add(NewNode)
                    returnNode = GetNode(ChrStr)
                End If

                Return returnNode
            End Function

            ''' <summary>
            ''' Returns true if string is contined in trie (prefix) not as Word
            ''' </summary>
            ''' <param name="tree"></param>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Shared Function CheckPrefix(ByRef tree As Node, ByRef Str As String) As Boolean
                Str = Str.ToUpper
                Dim CurrentNode As Node = tree
                Dim found As Boolean = False

                Dim Pos As Integer = 0
                For Each chrStr As Char In Str
                    Pos += 1

                    'Check Chars
                    If CheckNodeExists(CurrentNode.Children, chrStr) = True Then
                        CurrentNode = GetNode(CurrentNode.Children, chrStr)
                        found = True
                    Else
                        found = False
                    End If
                Next
                Return found
            End Function
            ''' <summary>
            ''' Returns true if String is found as a prefix in trie
            ''' </summary>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Function FindPrefix(ByRef Tree As Node, ByRef Str As String) As Boolean
                Return CheckPrefix(Tree, Str)
            End Function

            ''' <summary>
            ''' Returns true if string is found as word in trie
            ''' </summary>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Function FindSentence(ByRef Tree As Node, ByRef Str As String) As Boolean
                Return CheckSentence(Tree, Str)
            End Function

            ''' <summary>
            ''' Returns true if String is found as a prefix in trie
            ''' </summary>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Function FindSentPrefix(ByRef Tree As Node, ByRef Str As String) As Boolean
                Return CheckSentPrefix(Tree, Str)
            End Function

            ''' <summary>
            ''' Returns true if string is found as word in trie
            ''' </summary>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Function FindWord(ByRef Tree As Node, ByRef Str As String) As Boolean
                Return CheckWord(Tree, Str)
            End Function
            ''' <summary>
            ''' Returns true if string is contined in trie (prefix) not as Word
            ''' </summary>
            ''' <param name="tree"></param>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Shared Function CheckSentPrefix(ByRef tree As Node, ByRef Str As String) As Boolean
                Dim CurrentNode As Node = tree
                Dim found As Boolean = False
                Str = Str.ToUpper
                Dim Pos As Integer = 0
                For Each chrStr As String In Str.Split(" ")
                    Pos += 1

                    'Check Chars
                    If CheckNodeExists(CurrentNode.Children, chrStr) = True Then
                        CurrentNode = GetNode(CurrentNode.Children, chrStr)
                        found = True
                    Else
                        found = False
                    End If
                Next
                Return found
            End Function
            ''' <summary>
            ''' Returns true if Word is found in trie
            ''' </summary>
            ''' <param name="tree"></param>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Shared Function CheckSentence(ByRef tree As Node, ByRef Str As String) As Boolean
                Str = Str.ToUpper
                Dim CurrentNode As Node = tree
                Dim found As Boolean = False
                'Position in Characterstr
                Dim Pos As Integer = 0
                For Each chrStr As String In Str.Split(" ")
                    Pos += 1

                    'Check Chars
                    If CheckNodeExists(CurrentNode.Children, chrStr) = True Then
                        CurrentNode = GetNode(CurrentNode.Children, chrStr)
                        found = True
                    Else
                        'Terminated before end of Word
                        found = False
                    End If
                Next

                'Check for end of word marker
                Return If(found = True, CheckNodeExists(CurrentNode.Children, "StopChar") = True, False)

            End Function

            ''' <summary>
            ''' Returns Matched Node to sender (used to recures children)
            ''' </summary>
            ''' <param name="Tree"></param>
            ''' <param name="NodeData"></param>
            ''' <returns></returns>
            Public Shared Function GetNode(ByRef Tree As List(Of Node), ByRef NodeData As String) As Node
                Dim Foundnode As New Node
                For Each item In Tree
                    If item.NodeData = NodeData Then
                        Foundnode = item
                    Else
                    End If
                Next
                Return Foundnode
            End Function

            ''' <summary>
            ''' checks if node exists in child nodes (used for trie trees (String added is the key and the data)
            ''' </summary>
            ''' <param name="Nodedata">Char string used as identifier</param>
            ''' <returns></returns>
            Public Shared Function CheckNodeExists(ByRef Children As List(Of Node), ByRef Nodedata As String) As Boolean
                'Check node does not exist
                Dim found As Boolean = False
                For Each mNode As Node In Children
                    If mNode.NodeData = Nodedata Then
                        found = True
                    Else
                    End If
                Next
                Return found
            End Function
            ''' <summary>
            ''' Returns true if Word is found in trie
            ''' </summary>
            ''' <param name="tree"></param>
            ''' <param name="Str"></param>
            ''' <returns></returns>
            Public Shared Function CheckWord(ByRef tree As Node, ByRef Str As String) As Boolean
                Str = Str.ToUpper
                Dim CurrentNode As Node = tree
                Dim found As Boolean = False
                'Position in Characterstr
                Dim Pos As Integer = 0
                For Each chrStr As Char In Str
                    Pos += 1

                    'Check Chars
                    If CheckNodeExists(CurrentNode.Children, chrStr) = True Then
                        CurrentNode = GetNode(CurrentNode.Children, chrStr)
                        found = True
                    Else
                        'Terminated before end of Word
                        found = False
                    End If
                Next

                'Check for end of word marker
                Return If(found = True, CheckNodeExists(CurrentNode.Children, "StopChar") = True, False)

            End Function

        End Class
        <Serializable>
        Public Class BinaryNode
            Public Left As BinaryNode
            Public Right As BinaryNode
            ''' <summary>
            ''' Used To hold CharacterStr (tries) Also Useful for Creating ID for node;
            ''' : (a String) can be used to store a specific Pathway :(legacy Functionality)
            ''' </summary>
            Public NodeData As String


            ''' <summary>
            ''' TreeControl Tree (once tree has been printed then the view Will Be populated)
            ''' </summary>
            Public Tree As System.Windows.Forms.TreeView

            ''' <summary>
            ''' Text Held in the node
            ''' </summary>
            Public NodeText As String


            Private Prnt As String = ""

            Public Function Contains(ByRef ExistingData As String) As Boolean
                Return If(ExistingData = Me.NodeData, True, If(ExistingData < NodeData, If(Left Is Nothing, False, Left.Contains(ExistingData)), If(Right Is Nothing, False, Right.Contains(ExistingData))))
            End Function
            Public Sub New(ByVal Data As String)
                Me.NodeData = Data
            End Sub


            ''' <summary>
            ''' Inserts new data into tree and adds node in appropriate place
            ''' </summary>
            ''' <param name="NewData"></param>
            Public Sub insert(ByVal NewData As Integer)
                If NewData <= NodeData Then
                    If Left IsNot Nothing Then
                        Left = New BinaryNode(NewData)
                    Else
                        Left.insert(NewData)
                    End If
                Else
                    If Right IsNot Nothing Then
                        Right = New BinaryNode(NewData)
                    Else
                        Right.insert(NewData)
                    End If
                End If

            End Sub

            ''' <summary>
            ''' Prints in order ABC Left then Root then Right B=Root A=Left C=Right
            ''' </summary>
            Public Sub PrintInOrder()
                If Left IsNot Nothing Then
                    Left.PrintInOrder()
                End If

                Prnt &= "Node :" & Me.NodeData & vbNewLine
                Dim nde As New System.Windows.Forms.TreeNode
                nde.Text = "Node :" & Me.NodeData & vbNewLine
                Tree.Nodes.Add(nde)
                If Right IsNot Nothing Then
                    Right.PrintInOrder()
                End If

            End Sub

            ''' <summary>
            ''' Prints in order ACB Left then Right Then Root B=Root A=Left C=Right
            ''' </summary>
            Public Sub PrintPostOrder()
                'Left Nodes
                If Left IsNot Nothing Then
                    Left.PrintInOrder()
                End If
                'Right nodes
                If Right IsNot Nothing Then
                    Right.PrintInOrder()
                End If

                'Root
                Prnt &= "Node :" & Me.NodeData & vbNewLine
                Dim nde As New System.Windows.Forms.TreeNode
                nde.Text = "Node :" & Me.NodeData & vbNewLine
                Tree.Nodes.Add(nde)
            End Sub

            ''' <summary>
            ''' Prints in order BAC Root then left then right B=Root A=Left C=Right
            ''' </summary>
            Public Sub PrintPreOrder()
                'Root
                Prnt &= "Node :" & Me.NodeData & vbNewLine
                Dim nde As New System.Windows.Forms.TreeNode
                nde.Text = "Node :" & Me.NodeData & vbNewLine
                Tree.Nodes.Add(nde)
                'Right nodes
                If Right IsNot Nothing Then
                    Right.PrintInOrder()
                End If
                'Left Nodes
                If Left IsNot Nothing Then
                    Left.PrintInOrder()
                End If
            End Sub

        End Class
        <Serializable>
        Public Class FrequencyNode
            Inherits Node

            ''' <summary>
            ''' Frequency of node in current path
            ''' </summary>
            Public NodeSequenceFrequency As Double

            ''' <summary>
            ''' creates a new node
            ''' </summary>
            ''' <param name="NodeData">Character to be added</param>
            Public Overloads Function CreateNode(ByRef NodeData As String, ByRef Level As Integer, ByRef ID As Integer) As FrequencyNode

                'Create node
                Dim NewNode As New FrequencyNode
                NewNode.NodeData = NodeData
                'create id
                NewNode.NodeID = ID
                NewNode.NodeLevel = Level
                NewNode.NodeSequenceFrequency = 1
                NewNode.NodeCharIndex = GenerateNodeCharIndex(NodeData)
                Return NewNode
            End Function

            ''' <summary>
            ''' Adds char to Node(children) Returning the child
            ''' </summary>
            ''' <param name="CurrentNode">node containing children</param>
            ''' <param name="ChrStr">String to be added </param>
            ''' <param name="CharPos">this denotes the level of the node</param>
            ''' <returns></returns>
            Public Overloads Function AddStringToTrie(ByRef CurrentNode As FrequencyNode, ByRef ChrStr As String, ByRef CharPos As Integer, NewNodeID As Integer) As FrequencyNode

                'start of tree
                Dim Text As String = ChrStr
                Dim returnNode As New FrequencyNode
                Dim NewNode As New FrequencyNode
                'Goto first (root)
                'does this node have siblings
                If CurrentNode.HasChildren() = True Then
                    'Check children
                    If CurrentNode.CheckNodeExists(ChrStr) = False Then
                        'create a new node for char
                        NewNode = CreateNode(ChrStr, CurrentNode.NodeLevel + 1, NewNodeID)
                        NewNode.NodeLevel = CharPos
                        'Add childnode
                        CurrentNode.Children.Add(NewNode)

                        returnNode = GetNode(ChrStr)
                    Else
                        CurrentNode.NodeSequenceFrequency += 1
                        returnNode = GetNode(ChrStr)
                    End If
                Else
                    'If no siblings then Create new node
                    'create a new node for char
                    NewNode = CreateNode(ChrStr, CurrentNode.NodeLevel + 1, NewNodeID)
                    NewNode.NodeLevel = CharPos
                    'Add childnode
                    CurrentNode.NodeSequenceFrequency += 1
                    CurrentNode.Children.Add(NewNode)
                    returnNode = GetNode(ChrStr)
                End If

                Return returnNode
            End Function

        End Class
        Public Class DecisionNode
            Public Left As DecisionNode
            Public Right As DecisionNode
            Public DecisionCriteria As String ' The feature/attribute being evaluated
            Public Outcome As String ' The decision outcome based on the criteria

            Public Sub New(ByVal Criteria As String, ByVal Outcome As String)
                Me.DecisionCriteria = Criteria
                Me.Outcome = Outcome
            End Sub

            Public Function MakeDecision(ByVal Features As Dictionary(Of String, String)) As String
                If Features.ContainsKey(DecisionCriteria) Then
                    Dim featureValue As String = Features(DecisionCriteria)
                    If featureValue = Outcome Then
                        Return Outcome
                    Else
                        If featureValue < Outcome Then
                            If Left IsNot Nothing Then
                                Return Left.MakeDecision(Features)
                            End If
                        Else
                            If Right IsNot Nothing Then
                                Return Right.MakeDecision(Features)
                            End If
                        End If
                    End If
                End If

                Return "Unknown"
            End Function
        End Class

        ''' <summary>
        ''' Used To Hold Risk Evaluation Data
        ''' </summary>
        <Serializable>
        Public Structure RiskNode

            Private mCost As Integer

            Private mExpectedMonetaryValue As Integer

            Private mExpectedMonetaryValueWithOutPerfectInformation As Integer

            Private mExpectedMonetaryValueWithPerfectInformation As Integer

            Private mGain As Integer

            Private mProbability As Integer

            Private mRegret As Integer

            Public Property Cost As Integer
                Get
                    Return mCost
                End Get
                Set(value As Integer)
                    mCost = value
                End Set
            End Property

            Public Property ExpectedMonetaryValue As Integer
                Get
                    Return mExpectedMonetaryValue
                End Get
                Set(value As Integer)
                    mExpectedMonetaryValue = value
                End Set
            End Property

            Public Property ExpectedMonetaryValueWithOutPerfectInformation As Integer
                Get
                    Return mExpectedMonetaryValueWithOutPerfectInformation
                End Get
                Set(value As Integer)
                    mExpectedMonetaryValueWithOutPerfectInformation = value
                End Set
            End Property

            Public Property ExpectedMonetaryValueWithPerfectInformation As Integer
                Get
                    Return mExpectedMonetaryValueWithPerfectInformation
                End Get
                Set(value As Integer)
                    mExpectedMonetaryValueWithPerfectInformation = value
                End Set
            End Property

            Public Property Gain As Integer
                Get
                    Return mGain
                End Get
                Set(value As Integer)
                    mGain = value
                End Set
            End Property

            Public Property Probability As Integer
                Get
                    Return mProbability
                End Get
                Set(value As Integer)
                    mProbability = value
                End Set
            End Property

            Public Property Regret As Integer
                Get
                    Return mRegret
                End Get
                Set(value As Integer)
                    mRegret = value
                End Set
            End Property

        End Structure
        <Serializable>
        Public Class VocabularyNode
            Inherits FrequencyNode

            ''' <summary>
            ''' The consumer must maintain the Vocabulary, Else each node would have
            ''' a duplicated copy of the vocabulary exploding the LLM
            ''' </summary>
            ''' <param name="sender">TriTree Node(Vocabulary Node)</param>
            ''' <param name="Data">Updated Value</param>
            Public Event VocabularyUpdated(ByRef sender As VocabularyNode, Data As VocabularyNode)

            Public Sub UpdateVocabulary(ByRef Term As VocabularyNode)
                RaiseEvent VocabularyUpdated(Me, Term)
            End Sub

            ''' <summary>
            ''' Adds char to Node(children) Returning the child
            ''' </summary>
            ''' <param name="CurrentNode">node containing children</param>
            ''' <param name="ChrStr">String to be added </param>
            ''' <param name="CharPos">this denotes the level of the node</param>
            ''' <returns></returns>
            Public Overloads Function AddStringToTrie(ByRef CurrentNode As VocabularyNode, ByRef ChrStr As String, ByRef CharPos As Integer, NewNodeID As Integer) As Node

                'start of tree
                Dim Text As String = ChrStr
                Dim returnNode As New VocabularyNode
                Dim NewNode As New VocabularyNode
                'Goto first (root)
                'does this node have siblings
                If CurrentNode.HasChildren() = True Then
                    'Check children
                    If CurrentNode.CheckNodeExists(ChrStr) = False Then
                        'create a new node for char
                        NewNode = CreateNode(ChrStr, CurrentNode.NodeLevel + 1, NewNodeID)
                        UpdateVocabulary(NewNode)
                        NewNode.NodeLevel = CharPos
                        'Add childnode
                        CurrentNode.Children.Add(NewNode)

                        returnNode = GetNode(ChrStr)
                    Else
                        CurrentNode.NodeSequenceFrequency += 1
                        returnNode = GetNode(ChrStr)
                    End If
                Else
                    'If no siblings then Create new node
                    'create a new node for char
                    NewNode = CreateNode(ChrStr, CurrentNode.NodeLevel + 1, NewNodeID)
                    UpdateVocabulary(NewNode)
                    NewNode.NodeLevel = CharPos
                    'Add childnode

                    CurrentNode.Children.Add(NewNode)
                    returnNode = GetNode(ChrStr)
                End If

                Return returnNode
            End Function

        End Class

    End Namespace
End Namespace
